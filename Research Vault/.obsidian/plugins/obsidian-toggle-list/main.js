/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/colormap/colorScale.js
var require_colorScale = __commonJS({
  "node_modules/colormap/colorScale.js"(exports, module2) {
    module2.exports = {
      "jet": [{ "index": 0, "rgb": [0, 0, 131] }, { "index": 0.125, "rgb": [0, 60, 170] }, { "index": 0.375, "rgb": [5, 255, 255] }, { "index": 0.625, "rgb": [255, 255, 0] }, { "index": 0.875, "rgb": [250, 0, 0] }, { "index": 1, "rgb": [128, 0, 0] }],
      "hsv": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 0.169, "rgb": [253, 255, 2] }, { "index": 0.173, "rgb": [247, 255, 2] }, { "index": 0.337, "rgb": [0, 252, 4] }, { "index": 0.341, "rgb": [0, 252, 10] }, { "index": 0.506, "rgb": [1, 249, 255] }, { "index": 0.671, "rgb": [2, 0, 253] }, { "index": 0.675, "rgb": [8, 0, 253] }, { "index": 0.839, "rgb": [255, 0, 251] }, { "index": 0.843, "rgb": [255, 0, 245] }, { "index": 1, "rgb": [255, 0, 6] }],
      "hot": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.3, "rgb": [230, 0, 0] }, { "index": 0.6, "rgb": [255, 210, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
      "spring": [{ "index": 0, "rgb": [255, 0, 255] }, { "index": 1, "rgb": [255, 255, 0] }],
      "summer": [{ "index": 0, "rgb": [0, 128, 102] }, { "index": 1, "rgb": [255, 255, 102] }],
      "autumn": [{ "index": 0, "rgb": [255, 0, 0] }, { "index": 1, "rgb": [255, 255, 0] }],
      "winter": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [0, 255, 128] }],
      "bone": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.376, "rgb": [84, 84, 116] }, { "index": 0.753, "rgb": [169, 200, 200] }, { "index": 1, "rgb": [255, 255, 255] }],
      "copper": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.804, "rgb": [255, 160, 102] }, { "index": 1, "rgb": [255, 199, 127] }],
      "greys": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 1, "rgb": [255, 255, 255] }],
      "yignbu": [{ "index": 0, "rgb": [8, 29, 88] }, { "index": 0.125, "rgb": [37, 52, 148] }, { "index": 0.25, "rgb": [34, 94, 168] }, { "index": 0.375, "rgb": [29, 145, 192] }, { "index": 0.5, "rgb": [65, 182, 196] }, { "index": 0.625, "rgb": [127, 205, 187] }, { "index": 0.75, "rgb": [199, 233, 180] }, { "index": 0.875, "rgb": [237, 248, 217] }, { "index": 1, "rgb": [255, 255, 217] }],
      "greens": [{ "index": 0, "rgb": [0, 68, 27] }, { "index": 0.125, "rgb": [0, 109, 44] }, { "index": 0.25, "rgb": [35, 139, 69] }, { "index": 0.375, "rgb": [65, 171, 93] }, { "index": 0.5, "rgb": [116, 196, 118] }, { "index": 0.625, "rgb": [161, 217, 155] }, { "index": 0.75, "rgb": [199, 233, 192] }, { "index": 0.875, "rgb": [229, 245, 224] }, { "index": 1, "rgb": [247, 252, 245] }],
      "yiorrd": [{ "index": 0, "rgb": [128, 0, 38] }, { "index": 0.125, "rgb": [189, 0, 38] }, { "index": 0.25, "rgb": [227, 26, 28] }, { "index": 0.375, "rgb": [252, 78, 42] }, { "index": 0.5, "rgb": [253, 141, 60] }, { "index": 0.625, "rgb": [254, 178, 76] }, { "index": 0.75, "rgb": [254, 217, 118] }, { "index": 0.875, "rgb": [255, 237, 160] }, { "index": 1, "rgb": [255, 255, 204] }],
      "bluered": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 1, "rgb": [255, 0, 0] }],
      "rdbu": [{ "index": 0, "rgb": [5, 10, 172] }, { "index": 0.35, "rgb": [106, 137, 247] }, { "index": 0.5, "rgb": [190, 190, 190] }, { "index": 0.6, "rgb": [220, 170, 132] }, { "index": 0.7, "rgb": [230, 145, 90] }, { "index": 1, "rgb": [178, 10, 28] }],
      "picnic": [{ "index": 0, "rgb": [0, 0, 255] }, { "index": 0.1, "rgb": [51, 153, 255] }, { "index": 0.2, "rgb": [102, 204, 255] }, { "index": 0.3, "rgb": [153, 204, 255] }, { "index": 0.4, "rgb": [204, 204, 255] }, { "index": 0.5, "rgb": [255, 255, 255] }, { "index": 0.6, "rgb": [255, 204, 255] }, { "index": 0.7, "rgb": [255, 153, 255] }, { "index": 0.8, "rgb": [255, 102, 204] }, { "index": 0.9, "rgb": [255, 102, 102] }, { "index": 1, "rgb": [255, 0, 0] }],
      "rainbow": [{ "index": 0, "rgb": [150, 0, 90] }, { "index": 0.125, "rgb": [0, 0, 200] }, { "index": 0.25, "rgb": [0, 25, 255] }, { "index": 0.375, "rgb": [0, 152, 255] }, { "index": 0.5, "rgb": [44, 255, 150] }, { "index": 0.625, "rgb": [151, 255, 0] }, { "index": 0.75, "rgb": [255, 234, 0] }, { "index": 0.875, "rgb": [255, 111, 0] }, { "index": 1, "rgb": [255, 0, 0] }],
      "portland": [{ "index": 0, "rgb": [12, 51, 131] }, { "index": 0.25, "rgb": [10, 136, 186] }, { "index": 0.5, "rgb": [242, 211, 56] }, { "index": 0.75, "rgb": [242, 143, 56] }, { "index": 1, "rgb": [217, 30, 30] }],
      "blackbody": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.2, "rgb": [230, 0, 0] }, { "index": 0.4, "rgb": [230, 210, 0] }, { "index": 0.7, "rgb": [255, 255, 255] }, { "index": 1, "rgb": [160, 200, 255] }],
      "earth": [{ "index": 0, "rgb": [0, 0, 130] }, { "index": 0.1, "rgb": [0, 180, 180] }, { "index": 0.2, "rgb": [40, 210, 40] }, { "index": 0.4, "rgb": [230, 230, 50] }, { "index": 0.6, "rgb": [120, 70, 20] }, { "index": 1, "rgb": [255, 255, 255] }],
      "electric": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.15, "rgb": [30, 0, 100] }, { "index": 0.4, "rgb": [120, 0, 100] }, { "index": 0.6, "rgb": [160, 90, 0] }, { "index": 0.8, "rgb": [230, 200, 0] }, { "index": 1, "rgb": [255, 250, 220] }],
      "alpha": [{ "index": 0, "rgb": [255, 255, 255, 0] }, { "index": 1, "rgb": [255, 255, 255, 1] }],
      "viridis": [{ "index": 0, "rgb": [68, 1, 84] }, { "index": 0.13, "rgb": [71, 44, 122] }, { "index": 0.25, "rgb": [59, 81, 139] }, { "index": 0.38, "rgb": [44, 113, 142] }, { "index": 0.5, "rgb": [33, 144, 141] }, { "index": 0.63, "rgb": [39, 173, 129] }, { "index": 0.75, "rgb": [92, 200, 99] }, { "index": 0.88, "rgb": [170, 220, 50] }, { "index": 1, "rgb": [253, 231, 37] }],
      "inferno": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [31, 12, 72] }, { "index": 0.25, "rgb": [85, 15, 109] }, { "index": 0.38, "rgb": [136, 34, 106] }, { "index": 0.5, "rgb": [186, 54, 85] }, { "index": 0.63, "rgb": [227, 89, 51] }, { "index": 0.75, "rgb": [249, 140, 10] }, { "index": 0.88, "rgb": [249, 201, 50] }, { "index": 1, "rgb": [252, 255, 164] }],
      "magma": [{ "index": 0, "rgb": [0, 0, 4] }, { "index": 0.13, "rgb": [28, 16, 68] }, { "index": 0.25, "rgb": [79, 18, 123] }, { "index": 0.38, "rgb": [129, 37, 129] }, { "index": 0.5, "rgb": [181, 54, 122] }, { "index": 0.63, "rgb": [229, 80, 100] }, { "index": 0.75, "rgb": [251, 135, 97] }, { "index": 0.88, "rgb": [254, 194, 135] }, { "index": 1, "rgb": [252, 253, 191] }],
      "plasma": [{ "index": 0, "rgb": [13, 8, 135] }, { "index": 0.13, "rgb": [75, 3, 161] }, { "index": 0.25, "rgb": [125, 3, 168] }, { "index": 0.38, "rgb": [168, 34, 150] }, { "index": 0.5, "rgb": [203, 70, 121] }, { "index": 0.63, "rgb": [229, 107, 93] }, { "index": 0.75, "rgb": [248, 148, 65] }, { "index": 0.88, "rgb": [253, 195, 40] }, { "index": 1, "rgb": [240, 249, 33] }],
      "warm": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [172, 0, 187] }, { "index": 0.25, "rgb": [219, 0, 170] }, { "index": 0.38, "rgb": [255, 0, 130] }, { "index": 0.5, "rgb": [255, 63, 74] }, { "index": 0.63, "rgb": [255, 123, 0] }, { "index": 0.75, "rgb": [234, 176, 0] }, { "index": 0.88, "rgb": [190, 228, 0] }, { "index": 1, "rgb": [147, 255, 0] }],
      "cool": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.13, "rgb": [116, 0, 218] }, { "index": 0.25, "rgb": [98, 74, 237] }, { "index": 0.38, "rgb": [68, 146, 231] }, { "index": 0.5, "rgb": [0, 204, 197] }, { "index": 0.63, "rgb": [0, 247, 146] }, { "index": 0.75, "rgb": [0, 255, 88] }, { "index": 0.88, "rgb": [40, 255, 8] }, { "index": 1, "rgb": [147, 255, 0] }],
      "rainbow-soft": [{ "index": 0, "rgb": [125, 0, 179] }, { "index": 0.1, "rgb": [199, 0, 180] }, { "index": 0.2, "rgb": [255, 0, 121] }, { "index": 0.3, "rgb": [255, 108, 0] }, { "index": 0.4, "rgb": [222, 194, 0] }, { "index": 0.5, "rgb": [150, 255, 0] }, { "index": 0.6, "rgb": [0, 255, 55] }, { "index": 0.7, "rgb": [0, 246, 150] }, { "index": 0.8, "rgb": [50, 167, 222] }, { "index": 0.9, "rgb": [103, 51, 235] }, { "index": 1, "rgb": [124, 0, 186] }],
      "bathymetry": [{ "index": 0, "rgb": [40, 26, 44] }, { "index": 0.13, "rgb": [59, 49, 90] }, { "index": 0.25, "rgb": [64, 76, 139] }, { "index": 0.38, "rgb": [63, 110, 151] }, { "index": 0.5, "rgb": [72, 142, 158] }, { "index": 0.63, "rgb": [85, 174, 163] }, { "index": 0.75, "rgb": [120, 206, 163] }, { "index": 0.88, "rgb": [187, 230, 172] }, { "index": 1, "rgb": [253, 254, 204] }],
      "cdom": [{ "index": 0, "rgb": [47, 15, 62] }, { "index": 0.13, "rgb": [87, 23, 86] }, { "index": 0.25, "rgb": [130, 28, 99] }, { "index": 0.38, "rgb": [171, 41, 96] }, { "index": 0.5, "rgb": [206, 67, 86] }, { "index": 0.63, "rgb": [230, 106, 84] }, { "index": 0.75, "rgb": [242, 149, 103] }, { "index": 0.88, "rgb": [249, 193, 135] }, { "index": 1, "rgb": [254, 237, 176] }],
      "chlorophyll": [{ "index": 0, "rgb": [18, 36, 20] }, { "index": 0.13, "rgb": [25, 63, 41] }, { "index": 0.25, "rgb": [24, 91, 59] }, { "index": 0.38, "rgb": [13, 119, 72] }, { "index": 0.5, "rgb": [18, 148, 80] }, { "index": 0.63, "rgb": [80, 173, 89] }, { "index": 0.75, "rgb": [132, 196, 122] }, { "index": 0.88, "rgb": [175, 221, 162] }, { "index": 1, "rgb": [215, 249, 208] }],
      "density": [{ "index": 0, "rgb": [54, 14, 36] }, { "index": 0.13, "rgb": [89, 23, 80] }, { "index": 0.25, "rgb": [110, 45, 132] }, { "index": 0.38, "rgb": [120, 77, 178] }, { "index": 0.5, "rgb": [120, 113, 213] }, { "index": 0.63, "rgb": [115, 151, 228] }, { "index": 0.75, "rgb": [134, 185, 227] }, { "index": 0.88, "rgb": [177, 214, 227] }, { "index": 1, "rgb": [230, 241, 241] }],
      "freesurface-blue": [{ "index": 0, "rgb": [30, 4, 110] }, { "index": 0.13, "rgb": [47, 14, 176] }, { "index": 0.25, "rgb": [41, 45, 236] }, { "index": 0.38, "rgb": [25, 99, 212] }, { "index": 0.5, "rgb": [68, 131, 200] }, { "index": 0.63, "rgb": [114, 156, 197] }, { "index": 0.75, "rgb": [157, 181, 203] }, { "index": 0.88, "rgb": [200, 208, 216] }, { "index": 1, "rgb": [241, 237, 236] }],
      "freesurface-red": [{ "index": 0, "rgb": [60, 9, 18] }, { "index": 0.13, "rgb": [100, 17, 27] }, { "index": 0.25, "rgb": [142, 20, 29] }, { "index": 0.38, "rgb": [177, 43, 27] }, { "index": 0.5, "rgb": [192, 87, 63] }, { "index": 0.63, "rgb": [205, 125, 105] }, { "index": 0.75, "rgb": [216, 162, 148] }, { "index": 0.88, "rgb": [227, 199, 193] }, { "index": 1, "rgb": [241, 237, 236] }],
      "oxygen": [{ "index": 0, "rgb": [64, 5, 5] }, { "index": 0.13, "rgb": [106, 6, 15] }, { "index": 0.25, "rgb": [144, 26, 7] }, { "index": 0.38, "rgb": [168, 64, 3] }, { "index": 0.5, "rgb": [188, 100, 4] }, { "index": 0.63, "rgb": [206, 136, 11] }, { "index": 0.75, "rgb": [220, 174, 25] }, { "index": 0.88, "rgb": [231, 215, 44] }, { "index": 1, "rgb": [248, 254, 105] }],
      "par": [{ "index": 0, "rgb": [51, 20, 24] }, { "index": 0.13, "rgb": [90, 32, 35] }, { "index": 0.25, "rgb": [129, 44, 34] }, { "index": 0.38, "rgb": [159, 68, 25] }, { "index": 0.5, "rgb": [182, 99, 19] }, { "index": 0.63, "rgb": [199, 134, 22] }, { "index": 0.75, "rgb": [212, 171, 35] }, { "index": 0.88, "rgb": [221, 210, 54] }, { "index": 1, "rgb": [225, 253, 75] }],
      "phase": [{ "index": 0, "rgb": [145, 105, 18] }, { "index": 0.13, "rgb": [184, 71, 38] }, { "index": 0.25, "rgb": [186, 58, 115] }, { "index": 0.38, "rgb": [160, 71, 185] }, { "index": 0.5, "rgb": [110, 97, 218] }, { "index": 0.63, "rgb": [50, 123, 164] }, { "index": 0.75, "rgb": [31, 131, 110] }, { "index": 0.88, "rgb": [77, 129, 34] }, { "index": 1, "rgb": [145, 105, 18] }],
      "salinity": [{ "index": 0, "rgb": [42, 24, 108] }, { "index": 0.13, "rgb": [33, 50, 162] }, { "index": 0.25, "rgb": [15, 90, 145] }, { "index": 0.38, "rgb": [40, 118, 137] }, { "index": 0.5, "rgb": [59, 146, 135] }, { "index": 0.63, "rgb": [79, 175, 126] }, { "index": 0.75, "rgb": [120, 203, 104] }, { "index": 0.88, "rgb": [193, 221, 100] }, { "index": 1, "rgb": [253, 239, 154] }],
      "temperature": [{ "index": 0, "rgb": [4, 35, 51] }, { "index": 0.13, "rgb": [23, 51, 122] }, { "index": 0.25, "rgb": [85, 59, 157] }, { "index": 0.38, "rgb": [129, 79, 143] }, { "index": 0.5, "rgb": [175, 95, 130] }, { "index": 0.63, "rgb": [222, 112, 101] }, { "index": 0.75, "rgb": [249, 146, 66] }, { "index": 0.88, "rgb": [249, 196, 65] }, { "index": 1, "rgb": [232, 250, 91] }],
      "turbidity": [{ "index": 0, "rgb": [34, 31, 27] }, { "index": 0.13, "rgb": [65, 50, 41] }, { "index": 0.25, "rgb": [98, 69, 52] }, { "index": 0.38, "rgb": [131, 89, 57] }, { "index": 0.5, "rgb": [161, 112, 59] }, { "index": 0.63, "rgb": [185, 140, 66] }, { "index": 0.75, "rgb": [202, 174, 88] }, { "index": 0.88, "rgb": [216, 209, 126] }, { "index": 1, "rgb": [233, 246, 171] }],
      "velocity-blue": [{ "index": 0, "rgb": [17, 32, 64] }, { "index": 0.13, "rgb": [35, 52, 116] }, { "index": 0.25, "rgb": [29, 81, 156] }, { "index": 0.38, "rgb": [31, 113, 162] }, { "index": 0.5, "rgb": [50, 144, 169] }, { "index": 0.63, "rgb": [87, 173, 176] }, { "index": 0.75, "rgb": [149, 196, 189] }, { "index": 0.88, "rgb": [203, 221, 211] }, { "index": 1, "rgb": [254, 251, 230] }],
      "velocity-green": [{ "index": 0, "rgb": [23, 35, 19] }, { "index": 0.13, "rgb": [24, 64, 38] }, { "index": 0.25, "rgb": [11, 95, 45] }, { "index": 0.38, "rgb": [39, 123, 35] }, { "index": 0.5, "rgb": [95, 146, 12] }, { "index": 0.63, "rgb": [152, 165, 18] }, { "index": 0.75, "rgb": [201, 186, 69] }, { "index": 0.88, "rgb": [233, 216, 137] }, { "index": 1, "rgb": [255, 253, 205] }],
      "cubehelix": [{ "index": 0, "rgb": [0, 0, 0] }, { "index": 0.07, "rgb": [22, 5, 59] }, { "index": 0.13, "rgb": [60, 4, 105] }, { "index": 0.2, "rgb": [109, 1, 135] }, { "index": 0.27, "rgb": [161, 0, 147] }, { "index": 0.33, "rgb": [210, 2, 142] }, { "index": 0.4, "rgb": [251, 11, 123] }, { "index": 0.47, "rgb": [255, 29, 97] }, { "index": 0.53, "rgb": [255, 54, 69] }, { "index": 0.6, "rgb": [255, 85, 46] }, { "index": 0.67, "rgb": [255, 120, 34] }, { "index": 0.73, "rgb": [255, 157, 37] }, { "index": 0.8, "rgb": [241, 191, 57] }, { "index": 0.87, "rgb": [224, 220, 93] }, { "index": 0.93, "rgb": [218, 241, 142] }, { "index": 1, "rgb": [227, 253, 198] }]
    };
  }
});

// node_modules/lerp/index.js
var require_lerp = __commonJS({
  "node_modules/lerp/index.js"(exports, module2) {
    function lerp(v0, v1, t) {
      return v0 * (1 - t) + v1 * t;
    }
    module2.exports = lerp;
  }
});

// node_modules/colormap/index.js
var require_colormap = __commonJS({
  "node_modules/colormap/index.js"(exports, module2) {
    "use strict";
    var colorScale = require_colorScale();
    var lerp = require_lerp();
    module2.exports = createColormap;
    function createColormap(spec) {
      var indicies, fromrgba, torgba, nsteps, cmap, colormap2, format, nshades, colors, alpha, i;
      if (!spec)
        spec = {};
      nshades = (spec.nshades || 72) - 1;
      format = spec.format || "hex";
      colormap2 = spec.colormap;
      if (!colormap2)
        colormap2 = "jet";
      if (typeof colormap2 === "string") {
        colormap2 = colormap2.toLowerCase();
        if (!colorScale[colormap2]) {
          throw Error(colormap2 + " not a supported colorscale");
        }
        cmap = colorScale[colormap2];
      } else if (Array.isArray(colormap2)) {
        cmap = colormap2.slice();
      } else {
        throw Error("unsupported colormap option", colormap2);
      }
      if (cmap.length > nshades + 1) {
        throw new Error(colormap2 + " map requires nshades to be at least size " + cmap.length);
      }
      if (!Array.isArray(spec.alpha)) {
        if (typeof spec.alpha === "number") {
          alpha = [spec.alpha, spec.alpha];
        } else {
          alpha = [1, 1];
        }
      } else if (spec.alpha.length !== 2) {
        alpha = [1, 1];
      } else {
        alpha = spec.alpha.slice();
      }
      indicies = cmap.map(function(c) {
        return Math.round(c.index * nshades);
      });
      alpha[0] = Math.min(Math.max(alpha[0], 0), 1);
      alpha[1] = Math.min(Math.max(alpha[1], 0), 1);
      var steps = cmap.map(function(c, i2) {
        var index = cmap[i2].index;
        var rgba = cmap[i2].rgb.slice();
        if (rgba.length === 4 && rgba[3] >= 0 && rgba[3] <= 1) {
          return rgba;
        }
        rgba[3] = alpha[0] + (alpha[1] - alpha[0]) * index;
        return rgba;
      });
      var colors = [];
      for (i = 0; i < indicies.length - 1; ++i) {
        nsteps = indicies[i + 1] - indicies[i];
        fromrgba = steps[i];
        torgba = steps[i + 1];
        for (var j = 0; j < nsteps; j++) {
          var amt = j / nsteps;
          colors.push([
            Math.round(lerp(fromrgba[0], torgba[0], amt)),
            Math.round(lerp(fromrgba[1], torgba[1], amt)),
            Math.round(lerp(fromrgba[2], torgba[2], amt)),
            lerp(fromrgba[3], torgba[3], amt)
          ]);
        }
      }
      colors.push(cmap[cmap.length - 1].rgb.concat(alpha[1]));
      if (format === "hex")
        colors = colors.map(rgb2hex);
      else if (format === "rgbaString")
        colors = colors.map(rgbaStr);
      else if (format === "float")
        colors = colors.map(rgb2float);
      return colors;
    }
    function rgb2float(rgba) {
      return [
        rgba[0] / 255,
        rgba[1] / 255,
        rgba[2] / 255,
        rgba[3]
      ];
    }
    function rgb2hex(rgba) {
      var dig, hex = "#";
      for (var i = 0; i < 3; ++i) {
        dig = rgba[i];
        dig = dig.toString(16);
        hex += ("00" + dig).substr(dig.length);
      }
      return hex;
    }
    function rgbaStr(rgba) {
      return "rgba(" + rgba.join(",") + ")";
    }
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ToggleList
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/suggester.ts
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_STATEGROUP = [
  [
    "- ",
    "- [ ] ",
    "- [x] || {tasks-today}",
    ""
  ],
  [
    "- [ ] ",
    "- [ ] #p1 ",
    "- [ ] #p2 ",
    "- [ ] #p3 "
  ],
  [
    "- ? ",
    "- ! ",
    "- ~ "
  ]
];
var DEFAULT_CMD = [
  {
    index: 0,
    pop: false,
    name: "Task",
    tmp_name: "Task",
    bindings: [0]
  },
  {
    index: 1,
    pop: false,
    name: "Task Priority",
    tmp_name: "Task Priority",
    bindings: [1]
  },
  {
    index: 2,
    pop: false,
    name: "Call out",
    tmp_name: "Call out",
    bindings: [2]
  },
  {
    index: 3,
    pop: false,
    name: "Task + Callout",
    tmp_name: "Task + Callout",
    bindings: [2, 0]
  }
];
var EMPTY_TOKEN = "{PARAGRAPH}";
var OLD_DATE = "{tasks-today}";
var PopState = class {
  constructor() {
    this.popon = false;
    this.hot = false;
    this.incr = 0;
  }
};
var Setup = class {
  constructor(text) {
    this.index = 0;
    this.update(text);
  }
  update(text = "") {
    this.all_states = text.replace(EMPTY_TOKEN, "");
    this.all_states = this.all_states.replace(OLD_DATE, "\u2705 {time:: YYYY-MM-DD}");
    this.states = this.all_states.split("\n");
    const ori_states = this.states;
    const tmp = /* @__PURE__ */ new Map();
    const new_tmp = /* @__PURE__ */ new Map();
    ori_states.forEach((os, idx) => tmp.set(os, idx));
    this.sorteds = ori_states.slice(0);
    this.sorteds = this.sorteds.sort((a, b) => b.length - a.length);
    this.sorteds.forEach((ss, idx) => new_tmp.set(idx, tmp.get(ss)));
    this.states_dict = new_tmp;
  }
};
var Command = class {
  constructor(cmd) {
    this.index = cmd.index || 0;
    this.name = cmd.name || "";
    this.tmp_name = this.name;
    this.bindings = cmd.bindings || Array();
    this.isPopOver = cmd.isPopOver || false;
  }
};
var ToggleListSettings = class {
  constructor(fromFile) {
    var _a;
    this.pop_state = new PopState();
    this.plot = false;
    this.cmd_list = fromFile == null ? void 0 : fromFile.cmd_list.map((cmd) => new Command(cmd));
    this.setup_list = (_a = fromFile == null ? void 0 : fromFile.setup_list) == null ? void 0 : _a.map((setup) => new Setup((setup == null ? void 0 : setup.all_states) || ""));
    if (!this.setup_list) {
      this.reset_setup_list();
    }
    if (!this.cmd_list) {
      this.reset_cmd_list();
    }
    this.validate();
  }
  addStateGroup() {
    const chosen = DEFAULT_STATEGROUP.at(Math.floor(Math.random() * DEFAULT_STATEGROUP.length)) || [];
    this.setup_list.push(new Setup(chosen.join("\n")));
  }
  validate() {
    this.cleanSetupList();
    this.cleanCmdList();
  }
  reset_setup_list() {
    this.setup_list = DEFAULT_STATEGROUP.map((setup) => {
      return new Setup(setup.join("\n"));
    });
  }
  reset_cmd_list() {
    this.cmd_list = DEFAULT_CMD.map((cmd) => {
      return new Command(cmd);
    });
  }
  reset() {
    this.reset_setup_list();
    this.reset_cmd_list();
    this.validate();
  }
  cleanSetupList() {
    this.setup_list = this.setup_list.map((setup) => {
      const states = setup.states;
      const states_ary = [...new Set(states)];
      return new Setup(states_ary.join("\n"));
    });
    this.setup_list.forEach((setup, idx) => setup.index = idx);
  }
  cleanCmdList() {
    this.cmd_list.forEach((cmd) => {
      cmd.bindings = cmd.bindings.filter((b) => b < this.setup_list.length);
    });
    this.cmd_list = this.cmd_list.filter((cmd) => cmd.bindings.length > 0);
  }
  cleanCmdListAfterSetupRemoved(removedIdx) {
    this.cmd_list.forEach((cmd) => {
      const nbinding = cmd.bindings.map(function(b) {
        return b > removedIdx ? b - 1 : b == removedIdx ? -1 : b;
      });
      cmd.bindings = nbinding.filter((b) => b >= 0);
    });
  }
  removeSetup(setup) {
    const index = setup.index;
    this.cleanCmdListAfterSetupRemoved(index);
    this.setup_list.splice(index, 1)[0];
    this.validate();
  }
};

// src/tlAction.ts
var timeFormats = [
  { rule: /\\{time:: YYYY-MM-DD hh:mm\\}/, pattern: "\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}" },
  { rule: /\\{time:: YYYY\/MM\/DD hh:mm\\}/, pattern: "\\d{4}/\\d{2}/\\d{2} \\d{2}:\\d{2}" },
  { rule: /\\{time:: YYYY-MM-DD\\}/, pattern: "\\d{4}-\\d{2}-\\d{2}" },
  { rule: /\\{time:: YYYY\/MM\/DD\\}/, pattern: "\\d{4}/\\d{2}/\\d{2}" },
  { rule: /\\{time:: hh:mm:ss\\}/, pattern: "\\d{2}:\\d{2}:\\d{2}" },
  { rule: /\\{time:: hh:mm\\}/, pattern: "\\d{2}:\\d{2}" },
  { rule: /\\{time:: YYYY-MM\\}/, pattern: "\\d{4}-\\d{2}" },
  { rule: /\\{time:: YYYY\/MM\\}/, pattern: "\\d{4}/\\d{2}" },
  { rule: /\\{time:: MM-DD\\}/, pattern: "\\d{2}-\\d{2}" },
  { rule: /\\{time:: MM\/DD\\}/, pattern: "\\d{2}/\\d{2}" },
  { rule: /\\{time:: YYYY\\}/, pattern: "\\d{4}" },
  { rule: /\\{time:: MM\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: DD\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: hh\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: mm\\}/, pattern: "\\d{2}" },
  { rule: /\\{time:: ss\\}/, pattern: "\\d{2}" }
];
function formatDate(format, date) {
  const day = date.getDate();
  const month = date.getMonth() + 1;
  const year = date.getFullYear();
  const hours = date.getHours();
  const minutes = date.getMinutes();
  const seconds = date.getSeconds();
  const replacements = {
    "YYYY": year.toString(),
    "YY": String(year).slice(-2),
    "MM": month.toString().padStart(2, "0"),
    "DD": day.toString().padStart(2, "0"),
    "hh": hours.toString().padStart(2, "0"),
    "mm": minutes.toString().padStart(2, "0"),
    "ss": seconds.toString().padStart(2, "0"),
    "M": month.toString(),
    "D": day.toString(),
    "h": hours.toString(),
    "m": minutes.toString(),
    "s": seconds.toString()
  };
  let formattedDate = format;
  for (let key in replacements) {
    formattedDate = formattedDate.replace(key, replacements[key]);
  }
  return formattedDate;
}
function setupCursor(cursor, offset, origin_set, new_set) {
  const x0 = (origin_set == null ? void 0 : origin_set.x) || 0;
  const y0 = (origin_set == null ? void 0 : origin_set.y) || 0;
  const x1 = (new_set == null ? void 0 : new_set.x) || 0;
  const y1 = (new_set == null ? void 0 : new_set.y) || 0;
  const a = (origin_set == null ? void 0 : origin_set.a) || 0;
  const z = (origin_set == null ? void 0 : origin_set.z) || 0;
  if (cursor.ch <= x0)
    cursor.ch = x1;
  else if (cursor.ch <= x0 + a)
    cursor.ch = cursor.ch + offset;
  else if (cursor.ch > x0 + a && cursor.ch <= x0 + a + y0)
    cursor.ch = x1 + a;
  else
    cursor.ch = x1 + a + y1 + z;
  return cursor;
}
function triggerSuggestionEditorByToggleState(editor, cmd, settings, direction) {
  const cursor = editor.getCursor();
  const line = editor.getLine(cursor.line);
  for (let i = 0; i < cmd.bindings.length; i++) {
    const setup = settings.setup_list[cmd.bindings[i]];
    const r = match_sg(line, setup);
    if (r.success) {
      const stateIdx = r.offset;
      const result = processOneLine(line, setup, -1, direction);
      editor.setLine(cursor.line, result.content);
      const new_cursor = setupCursor(cursor, result.offset, result.origin_set, result.new_set);
      editor.setCursor(new_cursor.line, new_cursor.ch);
      if (cmd.isPopOver)
        settings.pop_state.hot = true;
      settings.pop_context = { setup, stateIdx, direction };
      return;
    }
  }
}
function popAction(editor, cmd, settings, direction, app) {
  const selections = editor.listSelections()[0];
  const isMultiLine = selections.anchor.line != selections.head.line;
  if (!isMultiLine) {
    return triggerSuggestionEditorByToggleState(editor, cmd, settings, direction);
  } else {
    return toggleAction(editor, settings.setup_list, cmd.bindings, direction);
  }
}
function renderEmptyLine(text) {
  const emptyline = EMPTY_TOKEN + "\n";
  const emptyline_last = "\n" + EMPTY_TOKEN;
  let result = text.replace(/(^\n)/gm, emptyline);
  result = result.replace(/\n$/gm, emptyline_last);
  if (result == "")
    result = EMPTY_TOKEN;
  return result;
}
function getFormatTime(time_format) {
  const now = new Date(new Date().getTime());
  const convertTime = formatDate(time_format, now) || "";
  return convertTime;
}
function applyTimeFormats(text) {
  const regex = /\{(time::.*)\}/;
  const ff = text.match(regex);
  const found = ff || [];
  let suffix = text;
  if (found.length > 0) {
    const tag = found[1];
    const tag_ = tag.split(":: ");
    const time_format = tag_[1];
    const convertTime = getFormatTime(time_format);
    suffix = suffix.replace("{" + found[1] + "}", convertTime);
  }
  return suffix;
}
function ChangeState(text, prev, next) {
  const pre = applyTimeFormats(next[0]) || "";
  const sur = applyTimeFormats(next[1]) || "";
  return pre + text + sur;
}
function getRegExp(text) {
  let t = text || "";
  t = t.replace(/([\.\+\*\?\^\$\(\)\[\]\{\}\|\\])/g, "\\$1");
  for (let i = 0; i < timeFormats.length; i++)
    t = t.replace(timeFormats[i].rule, timeFormats[i].pattern);
  return t;
}
function getCurrentState(text, states) {
  for (let i = 0; i < states.length; i++) {
    const s = states[i].split("||");
    const prefix = getRegExp(s[0]);
    const suffix = getRegExp(s[1]);
    let state_regex = new RegExp(`^(\\s*)${prefix}(.*)${suffix}$`);
    const result = text.match(state_regex) || [];
    if (result.length > 0) {
      return { sorted_idx: i, raw: result[2], idents: result[1] };
    }
  }
  return { sorted_idx: -1, raw: "" };
}
function separatePreSur(state) {
  const strings = state.split("||");
  strings.push("");
  return strings;
}
function roundAdd(a, b, low, high) {
  let result = a + b;
  if (result == high)
    result = low;
  if (result < low)
    result = high - 1;
  return result;
}
function getBlkID(line) {
  const blockIdRegex = /( \^[a-zA-Z0-9-]+)/;
  const blockIdMatch = line.match(blockIdRegex);
  const blockId = blockIdMatch ? blockIdMatch[0] : "";
  const lineWithoutBlockId = line.replace(blockIdRegex, "");
  return { blockId, lineWithoutBlockId };
}
function processOneLine(text, setup, specifyIdx, direction) {
  const { blockId, lineWithoutBlockId } = getBlkID(text);
  const cur_match = getCurrentState(lineWithoutBlockId, setup.sorteds);
  if (cur_match.sorted_idx < 0) {
    return { success: false, content: lineWithoutBlockId, offset: 0, origin_set: { x: 0, a: 0, y: 0, z: 0 }, new_set: { x: 0, a: 0, y: 0, z: 0 } };
  }
  const cur_idx = setup.states_dict.get(cur_match.sorted_idx) || 0;
  let next_idx = specifyIdx;
  if (specifyIdx < 0)
    next_idx = roundAdd(cur_idx, direction, 0, setup.states.length);
  const cur_pair = separatePreSur(setup.states[cur_idx]);
  const next_pair = separatePreSur(setup.states[next_idx]);
  let new_text = cur_match.idents + ChangeState(cur_match.raw, cur_pair, next_pair);
  let next_txt = next_pair[0];
  let cur_txt = cur_pair[0];
  next_txt = applyTimeFormats(next_txt);
  cur_txt = applyTimeFormats(cur_txt);
  new_text = new_text + blockId;
  const offset = next_txt.length - cur_txt.length;
  let x0 = applyTimeFormats(cur_pair[0]).length || 0;
  let y0 = applyTimeFormats(cur_pair[1]).length || 0;
  let z = blockId.length || 0;
  let x1 = applyTimeFormats(next_pair[0]).length || 0;
  let y1 = applyTimeFormats(next_pair[1]).length || 0;
  let A = cur_match.raw.length || 0;
  return {
    success: true,
    content: new_text,
    offset,
    origin_set: { x: x0, a: A, y: y0, z },
    new_set: { x: x1, a: A, y: y1, z }
  };
}
function match_sg(text, setup) {
  const cur_match = getCurrentState(text, setup.sorteds);
  if (cur_match.sorted_idx < 0) {
    return { success: false, content: text, offset: 0 };
  }
  const cur_idx = setup.states_dict.get(cur_match.sorted_idx) || 0;
  const cur_pair = separatePreSur(setup.states[cur_idx]);
  return { success: true, content: cur_pair[0], offset: cur_idx };
}
function toggleAction(editor, sg_list, bindings, direction) {
  let selection = editor.listSelections()[0];
  let cursor = editor.getCursor();
  let set_cur = false;
  if (selection.head.ch == selection.anchor.ch && selection.head.line == selection.anchor.line)
    set_cur = true;
  const head = selection.head.line;
  const anchor = selection.anchor.line;
  let start_line = head;
  let end_line = anchor;
  if (start_line > end_line) {
    start_line = anchor;
    end_line = head;
  }
  for (let i = start_line; i <= end_line; i++) {
    const origin = editor.getLine(i);
    let r = { success: false, content: origin, offset: 0, origin_set: { x: 0, y: 0, a: 0, z: 0 }, new_set: { x: 0, y: 0, a: 0, z: 0 } };
    for (let i2 = 0; i2 < bindings.length; i2++) {
      r = processOneLine(origin, sg_list[bindings[i2]], -1, direction);
      if (r.success)
        break;
    }
    editor.setLine(i, r.content);
    if (i == cursor.line) {
      cursor = setupCursor(cursor, r.offset, r.origin_set, r.new_set);
    }
    if (i == head) {
      const head_cursor = setupCursor(selection.head, r.offset, r.origin_set, r.new_set);
      selection.head = head_cursor;
    }
    if (i == anchor) {
      const anchor_cursor = setupCursor(selection.anchor, r.offset, r.origin_set, r.new_set);
      selection.anchor = anchor_cursor;
    }
  }
  editor.setSelection(selection.anchor, selection.head);
  if (set_cur)
    editor.setCursor(cursor);
}

// src/suggester.ts
function buildSuggestions(line_num, line, idx, setup, direction) {
  let suggestions = [];
  const N = setup.states.length;
  const nidx = (idx + direction + N) % N;
  const final = [...Array(N).keys()].map((i) => (i * direction + nidx + N) % N);
  for (let i = 0; i < N - 1; i++) {
    const curIdx = final[i];
    suggestions.push({
      displayText: setup.states[curIdx],
      appendText: line,
      insertAt: line_num,
      insertSkip: curIdx
    });
  }
  return suggestions;
}
var EditorSuggestor = class extends import_obsidian.EditorSuggest {
  constructor(app, settings) {
    super(app);
    this.settings = settings;
    this.popw = settings.pop_state;
  }
  onTrigger(cursor, editor, _file) {
    if (!this.popw.hot) {
      this.popw.popon = false;
    } else {
      this.popw.hot = false;
      const context = this.settings.pop_context;
      const line = editor.getLine(cursor.line);
      return { start: cursor, end: { line: cursor.line, ch: context.stateIdx }, query: line };
    }
    return null;
  }
  getSuggestions(context) {
    const line = context.query;
    const line_idx = context.start.line;
    let state_idx = context.end.ch;
    const pop_context = this.settings.pop_context;
    const N = pop_context.setup.states.length;
    this.popw.incr = 0;
    state_idx += (N + pop_context.direction) % N;
    const suggestions = buildSuggestions(line_idx, line, state_idx, pop_context.setup, pop_context.direction);
    const suggestionsWithContext = [];
    for (const suggestion of suggestions)
      suggestionsWithContext.push({ ...suggestion, context });
    this.popw.popon = true;
    return suggestionsWithContext;
  }
  renderSuggestion(value, el) {
    el.setText(value.displayText);
  }
  selectSuggestion(value, _evt) {
    const editor = value.context.editor;
    const line = value.appendText;
    const cur_steup = this.settings.pop_context.setup;
    const r = processOneLine(line, cur_steup, value.insertSkip || 0, 1);
    const line_idx = value.insertAt || 0;
    const cursor = editor.getCursor();
    editor.setLine(line_idx, r.content);
    const ch = cursor.ch + r.offset > r.content.length ? r.content.length : cursor.ch + r.offset;
    editor.setCursor(line_idx, ch);
    this.popw.popon = false;
    this.popw.incr = 0;
  }
};

// src/UI.ts
var import_obsidian2 = require("obsidian");

// src/stateDiagram.ts
var import_colormap = __toESM(require_colormap());
function genColorMap(samples) {
  const num = samples < 256 ? 256 : samples;
  const colors = (0, import_colormap.default)({
    colormap: "rainbow-soft",
    nshades: num,
    format: "hex",
    alpha: 0.5
  });
  return colors;
}
function drawConnectionForSG(state_group, statesAry, cmdIdx) {
  const edgeList = [];
  const sgLen = state_group.length;
  let fromIdx = 0;
  let toIdx = 0;
  for (let j = 0; j < sgLen - 1; j++) {
    for (let k = 0; k < statesAry.length; k++) {
      if (state_group[j] == statesAry[k])
        fromIdx = k;
      if (state_group[j + 1] == statesAry[k])
        toIdx = k;
    }
    edgeList.push({
      id: `edge${fromIdx}->${toIdx}`,
      fromNode: `${fromIdx}`,
      fromSide: "bottom",
      toNode: `${toIdx}`,
      toSide: "top",
      toEnd: "arrow",
      color: `${cmdIdx}`
    });
  }
  fromIdx = 0;
  toIdx = 0;
  for (let k = 0; k < statesAry.length; k++) {
    if (state_group[sgLen - 1] == statesAry[k])
      fromIdx = k;
    if (state_group[0] == statesAry[k])
      toIdx = k;
  }
  edgeList.push({
    id: `edge${fromIdx}->${toIdx}`,
    fromNode: `${fromIdx}`,
    fromSide: "bottom",
    toNode: `${toIdx}`,
    toSide: "left",
    toEnd: "arrow",
    color: `${cmdIdx}`
  });
  return edgeList;
}
async function genDiagramCanvas(settings, fileName) {
  const colors = genColorMap(settings.cmd_list.length);
  let transitions = [];
  const cmdNodes = [];
  for (let i = 0; i < settings.cmd_list.length; i++) {
    const cmd = settings.cmd_list[i];
    cmd.bindings.forEach((cmdIdx) => {
      transitions = transitions.concat(settings.setup_list[cmdIdx].states);
    });
    cmdNodes.push({
      id: `cmd${i}`,
      x: i * 200,
      y: -100,
      width: 150,
      height: 40,
      type: "text",
      text: cmd.name,
      color: `${i}`
    });
  }
  const statesSet = new Set(transitions);
  const statesAry = Array.from(statesSet);
  const stateNodes = statesAry.map((state, index) => ({
    id: `${index}`,
    x: index * 120,
    y: index * 80,
    width: 150,
    height: 40,
    type: "text",
    text: state.trim(),
    color: `${-1}`
  }));
  let edgeList = [];
  for (let i = 0; i < settings.cmd_list.length; i++) {
    const cmd = settings.cmd_list[i];
    cmd.bindings.forEach((cmdIdx) => {
      edgeList = edgeList.concat(drawConnectionForSG(settings.setup_list[cmdIdx].states, statesAry, i));
    });
  }
  await this.app.vault.create(fileName, JSON.stringify({
    nodes: cmdNodes.concat(stateNodes),
    edges: edgeList
  }));
}

// src/UI.ts
function genSGSection(tab) {
  const plugin = tab.plugin;
  const settings = tab.plugin.settings;
  tab.containerEl.createEl("h3", { text: "Setup The States to Toggle" });
  const setup_list = settings.setup_list;
  settings.setup_list.forEach((setup) => {
    addSetupUI(tab, setup);
  });
  new import_obsidian2.Setting(tab.containerEl).addButton((cb) => {
    cb.setButtonText("+ State Group").setCta().onClick(() => {
      settings.addStateGroup();
      plugin.checkNreload();
    });
  }).addButton((cb) => {
    cb.setIcon("checkmark");
    cb.setCta();
    cb.onClick(() => {
      plugin.checkNreload();
    });
  });
}
function addCmdUI(tab, cmd, cmdIdx) {
  const cmd_list = tab.plugin.settings.cmd_list;
  const settings = tab.plugin.settings;
  const plugin = tab.plugin;
  let desc = `${cmd.name}: ${cmd.isPopOver ? "popover" : ""} binding: ${cmd.bindings}`;
  const cmd_section = new import_obsidian2.Setting(tab.containerEl).setName(`${cmd.name}`).setDesc(desc).addToggle((cb) => {
    cb.setValue(cmd.isPopOver);
    cb.onChange((value) => {
      cmd.isPopOver = value;
      plugin.checkNreload();
    });
  }).addText((cb) => {
    cb.setValue(cmd.name);
    cb.setPlaceholder("Command Name");
    cb.onChange((value) => {
      cmd.name = value;
    });
  }).addText((cb) => {
    cb.setValue(cmd.bindings.map((x) => x.toString()).join(", "));
    cb.setPlaceholder("Indices of State Groups: 0, 1, 2");
    cb.onChange((value) => {
      cmd.bindings = value.split(",").map((x) => parseInt(x, 10));
    });
  }).addButton((cb) => {
    cb.setIcon("cross").setTooltip("Delete");
    cb.setCta();
    cb.onClick(() => {
      cmd_list.splice(cmdIdx, 1);
      plugin.checkNreload();
    });
  });
}
function genCMDSection(tab) {
  tab.containerEl.createEl("h3", { text: "Bind the Commands with State Groups" });
  tab.containerEl.createEl("p", { text: "Order of bindings matters if two SG share the same states" });
  tab.containerEl.createEl("p", { text: "Turn on suggestion will show a suggestion window to access all states" });
  tab.containerEl.createEl("p", { text: `[Suggection] [Name] [Binding SG]` });
  const cmd_list = tab.plugin.settings.cmd_list;
  for (let i = 0; i < cmd_list.length; i++) {
    addCmdUI(tab, cmd_list[i], i);
  }
  new import_obsidian2.Setting(tab.containerEl).addButton((cb) => {
    cb.setButtonText("+ Command");
    cb.setCta();
    cb.onClick(() => {
      const name = `Command ${cmd_list.length}`;
      if (tab.plugin.settings.setup_list.length > 0) {
        cmd_list.push(new Command({ index: cmd_list.length, name, bindings: [0] }));
        tab.plugin.checkNreload();
      } else {
        tab.plugin.sendNotify("No State Groups to bind");
      }
    });
  }).addButton((cb) => {
    cb.setButtonText("Click to validate");
    cb.setIcon("checkmark");
    cb.setCta();
    cb.onClick(() => {
      tab.plugin.checkNreload();
    });
  });
}
function genMISCSection(tab) {
  const cmd_list = tab.plugin.settings.cmd_list;
  const settings = tab.plugin.settings;
  const plugin = tab.plugin;
  const other = new import_obsidian2.Setting(tab.containerEl);
  other.addButton((cb) => {
    cb.setButtonText("\u{1F517} Generate State Diagram").setCta().onClick(async () => {
      const stamp = new Date().toISOString();
      const fileName = `TL-StateDiagram-${stamp}.canvas`.replace(/:/g, "-");
      genDiagramCanvas(tab.plugin.settings, fileName);
      new import_obsidian2.Notice(`ToggleList: Generate State Diagram at ./${fileName}`);
    });
  });
  other.addButton((cb) => {
    cb.setButtonText("\u{1F525} Hotkeys").setCta().onClick(() => {
      this.app.setting.openTabById("hotkeys").setQuery("ToggleList");
    });
  });
  other.addButton((cb) => {
    cb.setButtonText("\u21BB Reset").setCta().onClick(async () => {
      const stamp = new Date().toISOString();
      await this.app.vault.writeConfigJson(`plugins/obsidian-toggle-list/backup-${stamp}`, settings);
      new import_obsidian2.Notice(`ToggleList: Original config is saved in plugins/obsidian-toggle-list/backup-${stamp}.json`);
      plugin.reset();
      plugin.reloadSettingUI();
    });
  });
}
function genExplanation(tab) {
  const exp = tab.containerEl.createEl("div", { cls: "togglelist_div" });
  exp.innerHTML = `<button class="togglelist_btn">
		<a href="https://github.com/thingnotok/obsidian-toggle-list">README</a>
		</button>`;
}
function addSetupUI(container, setup) {
  const plugin = container.plugin;
  const sg_ui = new import_obsidian2.Setting(container.containerEl).addButton((cb) => {
    cb.setIcon("cross").setTooltip("Delete");
    cb.setCta().setCta().onClick(() => {
      plugin.settings.removeSetup(setup);
      plugin.checkNreload();
    });
  });
  const renderedText = renderEmptyLine(setup.all_states);
  sg_ui.setName("State Group: " + setup.index.toString());
  const ta = sg_ui.addTextArea((text) => {
    text.setValue(renderedText);
    text.onChange(async (text_value) => {
      setup.update(text_value);
    });
    text.inputEl.setAttribute("rows", setup.states.length.toFixed());
    text.inputEl.setAttribute("cols", "25");
    text.inputEl.style.cssText = "resize: none";
  });
}
var ToggleListSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  addSettingUI() {
    genSGSection(this);
    genCMDSection(this);
    genMISCSection(this);
    genExplanation(this);
  }
  display() {
    this.containerEl.empty();
    this.addSettingUI();
  }
};

// src/main.ts
function deleteObsidianCommand(app, commandId) {
  if (app.commands.findCommand(commandId)) {
    delete app.commands.commands[commandId];
    delete app.commands.editorCommands[commandId];
  }
}
var ToggleList = class extends import_obsidian3.Plugin {
  async onload() {
    await this.loadSettings();
    this.tab = new ToggleListSettingTab(this.app, this);
    this.addSettingTab(this.tab);
    this.registerActions();
    this.registerEditorSuggest(new EditorSuggestor(this.app, this.settings));
    this.cleanHotkeys();
  }
  async loadSettings() {
    const settings = await this.loadData();
    this.settings = new ToggleListSettings(settings);
    this.saveSettings();
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  cleanHotkeys() {
    const customKeys = this.app.hotkeyManager.customKeys;
    let cc = Object.keys(customKeys);
    for (let i = 0; i < cc.length; i++) {
      if (cc[i].slice(0, 20) == "obsidian-toggle-list") {
        if (cc[i].slice(-4) != "Prev" && cc[i].slice(-4) != "Next") {
          if (cc[i].slice(-4) == "-POP") {
            const name = cc[i].slice(0, -3) + "Next";
            customKeys[name] = customKeys[cc[i]];
          }
          delete customKeys[cc[i]];
        }
      }
    }
    const cmds = this.settings.cmd_list;
    cc = Object.keys(customKeys);
    for (let i = 0; i < cc.length; i++) {
      const name = cc[i].slice(21, -5);
      if (cmds.find((e) => e.name == name) !== void 0) {
        delete customKeys[cc[i]];
      }
    }
  }
  unregisterActions() {
    this.settings.registedCmdName.forEach((cmd) => this.unregistAction(`obsidian-toggle-list:${cmd}`));
    this.settings.registedCmdName = [];
  }
  unregistAction(cmd) {
    deleteObsidianCommand(this.app, cmd);
  }
  registerActions() {
    const sg_list = this.settings.setup_list;
    const reg = Array();
    this.settings.cmd_list.forEach((cmd) => {
      this.registerAction(cmd, sg_list);
      reg.push(`${cmd.name}-Next`);
      reg.push(`${cmd.name}-Prev`);
    });
    this.settings.registedCmdName = reg;
  }
  registerAction(cmd, sg_list) {
    const n_name = `${cmd.name}-Next`;
    const p_name = `${cmd.name}-Prev`;
    this.addCommand({
      id: n_name,
      name: n_name,
      icon: "right-arrow",
      editorCallback: (editor, view) => {
        popAction(editor, cmd, this.settings, 1, this.app);
      }
    });
    this.addCommand({
      id: p_name,
      name: p_name,
      icon: "left-arrow",
      editorCallback: (editor, view) => {
        popAction(editor, cmd, this.settings, -1, this.app);
      }
    });
  }
  checkNreload() {
    this.settings.validate();
    this.unregisterActions();
    this.registerActions();
    this.saveSettings();
    this.reloadSettingUI();
  }
  reloadSettingUI() {
    this.tab.display();
  }
  reset() {
    this.unregisterActions();
    this.settings.reset();
  }
  sendNotify(text) {
    new import_obsidian3.Notice(text);
  }
};

/* nosourcemap */